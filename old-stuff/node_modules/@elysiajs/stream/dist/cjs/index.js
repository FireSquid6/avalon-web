"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  Stream: () => Stream,
  default: () => src_default,
  wait: () => wait
});
module.exports = __toCommonJS(src_exports);
var import_nanoid = require("nanoid");
var encoder = new TextEncoder();
var wait = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
var Stream = class _Stream {
  constructor(callback, { retry, event } = {}) {
    this.$passthrough = "value";
    this.label = "";
    this.labelUint8Array = new Uint8Array();
    this.wait = wait;
    if (retry) this._retry = retry;
    if (event) this._event = event;
    if (retry || event) this.composeLabel();
    switch (typeof callback) {
      case "function":
      case "undefined":
        this.stream = new ReadableStream({
          start: (controller) => {
            this.controller = controller;
            callback?.(this);
          },
          cancel: (controller) => {
            controller.close();
          }
        });
        break;
      default:
        this.stream = new ReadableStream({
          start: async (controller) => {
            this.controller = controller;
            try {
              for await (const chunk of await callback)
                this.send(chunk);
              controller.close();
            } catch {
              if (callback instanceof Promise)
                callback = await callback;
              if (callback === null) return controller.close();
              const isResponse = callback instanceof Response;
              if (isResponse || callback instanceof ReadableStream) {
                const reader = isResponse ? callback.body?.getReader() : callback.getReader();
                if (!reader) return controller.close();
                while (true) {
                  const { done, value } = await reader.read();
                  this.send(value);
                  if (done) {
                    controller.close();
                    break;
                  }
                }
              }
            }
          }
        });
    }
  }
  composeLabel() {
    this.label = "";
    if (this._event) this.label += `event: ${this._event}
`;
    if (this._retry) this.label += `retry: ${this._retry}
`;
    if (this.label) this.labelUint8Array = encoder.encode(this.label);
  }
  get retry() {
    return this._retry;
  }
  set retry(retry) {
    this._retry = retry;
    this.composeLabel();
  }
  get event() {
    return this._event;
  }
  set event(event) {
    this._event = event;
    this.composeLabel();
  }
  static concatUintArray(a, b) {
    const arr = new Uint8Array(a.length + b.length);
    arr.set(a, 0);
    arr.set(b, a.length);
    return arr;
  }
  send(data) {
    if (!this.controller || data === "" || data === void 0) return;
    if (data instanceof Uint8Array) {
      this.controller.enqueue(
        this.label ? _Stream.concatUintArray(this.labelUint8Array, data) : data
      );
    } else
      this.controller.enqueue(
        encoder.encode(
          typeof data === "string" && data.includes("id:") ? data + (this._event && !data.includes("event:") ? `
event: ${this._event}` : "") + (this._retry && !data.includes("retry:") ? `\retry: ${this.retry}` : "") : `id: ${(0, import_nanoid.nanoid)()}
${this.label}data: ${typeof data === "object" ? JSON.stringify(data) : data}

`
        )
      );
  }
  close() {
    this.controller?.close();
  }
  get value() {
    return this.stream;
  }
  toResponse() {
    return this.value;
  }
};
var src_default = Stream;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Stream,
  wait
});
